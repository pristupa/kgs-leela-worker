import json
import time

import pika
import pika.amqp_object
import pika.channel

from .database import Database
from .leela_worker import GameNotFoundError
from .leela_worker import LeelaWorker
from .logger import logger
from .settings import settings


class Application:

    def __init__(self):
        parameters = pika.URLParameters(settings['amqp_url'])
        self._amqp_channel = None
        self._amqp_connection = pika.SelectConnection(parameters, self._on_connected)
        self._db = Database()
        self._leela_worker = LeelaWorker(self._db)

    def start(self):
        try:
            logger.info(f"Working with {settings['kilo_playouts']}000 playouts")
            time.sleep(3)
            logger.info('Listening the queue...')
            # Loop so we can communicate with RabbitMQ
            self._amqp_connection.ioloop.start()
        except KeyboardInterrupt:
            logger.info('Gracefully closing connections...')
            try:
                # Gracefully close the connections
                self._amqp_connection.close()
                # Loop until we're fully closed, will stop on its own
                self._amqp_connection.ioloop.start()
            except Exception:
                pass  # Fail silently

    def _handle_delivery(
            self,
            channel: pika.channel.Channel,
            method: pika.spec.Basic.Deliver,
            properties: pika.BasicProperties,
            body: bytes,
    ):
        """Called when we receive a message from RabbitMQ"""
        try:
            data = json.loads(body)
        except json.decoder.JSONDecodeError:
            logger.warn(f'Ignoring message with invalid JSON: {body}')
            channel.basic_ack(delivery_tag=method.delivery_tag)
            return

        try:
            game_id = data['game_id']
            if not isinstance(game_id, int):
                raise ValueError(f'Invalid game_id: {game_id}')
        except (KeyError, ValueError):
            logger.warn(f'Ignoring message, cannot find an integer "game_id": {body}')
            channel.basic_ack(delivery_tag=method.delivery_tag)
            return

        try:
            kilo_playouts = data['kilo_playouts']
            if not isinstance(kilo_playouts, int):
                raise ValueError(f'Invalid kilo_playouts: {kilo_playouts}')
        except (KeyError, ValueError):
            logger.warn(f"Invalid kilo_playouts ({data.get('kilo_playouts')}), "
                        f"using default: {settings['kilo_playouts']}")
            kilo_playouts = int(settings['kilo_playouts'])

        try:
            self._leela_worker.calculate_game(game_id, kilo_playouts)
            logger.info(f'Done: game_id={game_id}, playouts={kilo_playouts * 1000}')
            channel.basic_ack(delivery_tag=method.delivery_tag)
        except GameNotFoundError:
            logger.error(f'Ignoring message, game not found: {game_id}')
            channel.basic_ack(delivery_tag=method.delivery_tag)
            return
        except FileNotFoundError as exception:
            logger.error(f'Leela did not seem to produce any result for game {game_id}: ' + str(exception))
            return

    def _on_connected(self, connection):
        """Called when we are fully connected to RabbitMQ"""
        # Open a channel
        connection.channel(self._on_channel_open)

    def _on_channel_open(self, new_channel):
        """Called when our channel has opened"""
        self._amqp_channel = new_channel
        self._amqp_channel.queue_declare(
            queue=settings['amqp_queue'],
            durable=True,
            exclusive=False,
            auto_delete=False,
            callback=self._on_queue_declared,
        )

    def _on_queue_declared(self, frame):
        """Called when RabbitMQ has told us our Queue has been declared, frame is the response from RabbitMQ"""
        self._amqp_channel.basic_consume(self._handle_delivery, queue=settings['amqp_queue'])
